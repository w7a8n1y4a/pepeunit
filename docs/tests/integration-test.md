# Интеграционные тесты - Backend

:::tip Какую роль выполняют интеграционные тесты?
Проверка корректности работы основных сценариев приложения. По сути они фиксируют работу функционала приложения. Благодаря данным тестам, разработчики [Backend](/definitions#backend), могут не сомневаться в изменениях кодовой базы 
:::

:::warning
Тестовые сценарии проверяют исключительно бизнеслогику, они не стремятся проверить то как работает какой-либо из слоёв API.
:::

## Запуск

0. Настроить дополнительные [ENV переменные Backend](/deployment/env-variables#backend):

    Переменная Backend | Что делает ?
    -- | --
    `TEST_INTEGRATION_CLEAR_DATA` | Удаление всех связанных с тестом данных, происходит в начале и конце теста. Но если указать данную переменную как `False`, удаление в конце теста происходить не будет - удобно для откладки ошибок
    `TEST_INTEGRATION_PRIVATE_REPO_JSON` | Это указание на приватные репозитории в [Gitlab](/definitions#gitlab) и [Github](/definitions#github), структура репозиториев, соответствует такой же для публичных репозиториев, ссылки на них есть в `tests.integration.conftest.py`

1. Запустить [Backend](/definitions#backend) одной из команд, число `workers` может быть произвольным:
   ```
   uvicorn app.main:app --host 0.0.0.0 --port 8555 --log-level info --workers 4
   gunicorn app.main:app -b 0.0.0.0:8555 --workers=4 -k uvicorn.workers.UvicornWorker --log-level=info
   ```
1. Запустить интеграционное тестирование можно командой
   ```
   pytest tests -v
   ```

## Cценарии User

### Сценарий 1 - Cоздание
- Создать Пользователей
- Попытаться создать Пользователя с существующим login
- Установить роль Админа одному из Пользователей

### Сценарий 2 - Авторизация
- Получить токен авторизации для всех Пользователей
- Попытаться получить токен с не валидным password
- Попытаться получить токен с не валидным login

### Сценарий 3 - Верификация
- Проверить верификацию с несуществующим кодом
- Сгенерировать верификационный код всем созданным Пользователям
- Проверить верификационный код для всех созданных Пользователей
- Проверить что кодов больше нет в redis

### Сценарий 4 - Блокировка и Разблокировка
- Заблокировать Пользователя
- Разблокировать Пользователя
- Попытаться заблокировать Пользователя не имея прав Администратора
- Попытаться разблокировать Пользователя не имея прав Администратора

### Сценарий 5 - Модификация
- Обновить логин на не занятый
- Обновить логин на занятый
- Проверка обновления пароля

### Сценарий 6 - Множественная выборка
- Выборка со всеми параметрами для получения списка

## Cценарии Repo

### Сценарий 1 - Создание
- Создать открытый/закрытый repo gitlab
- Создать открытый/закрытый repo github
- Создать Repo с разными уровнями видимости
- Попытаться создать Repo с существующим именем
- Попытаться создать Repo с невалидным url
- Попытаться создать закрытый Repo с невалидными кредами

### Cценарий 2 - Модификация 
- Установить всем repo default ветку
- Обновить название на не занятое
- Обновить название на занятое
- Изменить автоматическое обновление на ручное
- Установить все три вида апдейтов - ручной, автоматический по коммиту, автоматический по тэгу
- Установить для компилируемых - default ветку

### Cценарий 3 - Получить все комиты по ветке
- Получить первые 10 коммитов
- Проверить первый коммит
- Проверить выборку коммитов для не существующей ветки

### Сценарий 4 - Получение доступных платформ
- Проверка получения платформ от удалённого репозитория
- Проверка получения платформ доступных на инстансе по тэгам
- Проверка получения не существующих тэгов
- Проверка получения коммитов без тэгов
- Проверка получения коммитов с тэгами

### Сценарий 5 - Обновить креды
Для закрытых репозиториев gitlab и github

- Обновить креды на невалидные
- Попробовать обновить репозиторий с невалидными кредами
- Обновить креды на валидные

### Сценарий 6 - Установить ветку по умолчанию
- Для всех тестовых Repo - проставить каждой из сущностей первую ветку по умолчанию 
- Попробовать проставить не существующую ветку по умолчанию

### Сценарий 7 - Обновить физический репозиторий
- Удалить один из тестовых физических Repo
- Обновить все тестовые физические Repo

### Сценарий 8 - Удаление
- Удалить репозиторий к которому не присоеденены Unit

### Сценарий 9 - Множественная выборка
- Выборка по создателю и автообновляемости
- Выборка со всеми параметрами

## Сценарии Unit

### Сценарий 1 - Создание

- Создать автообновлеяемые Unit
- Создать все 3 варианта видимости
- Создать Unit для всех сценариев обновления:
    На основе | Форма обновления Unit | Форма обновления Repo 
    -- | -- | -- 
    Interpreter | Руками | Руками
    Interpreter | Руками | По последнему Коммиту
    Interpreter | Руками | По последнему Тэгу
    Interpreter | Автоматически | Руками
    Interpreter | Автоматически | По последнему Коммиту
    Interpreter | Автоматически | По последнему Тэгу
    Compiler | Руками | Руками
    Compiler | Руками | По последнему Тэгу
    Compiler | Автоматически | Руками
    Compiler | Автоматически | По последнему Тэгу
- Создать Unit с существующим именем
- Попытаться Unit создать для Repo у которого нет стандарной ветки
- Попытатьсяc cоздать Unit от верссии Repo у которого нет env_example.json и schema_example.json

### Сценарий 2 - Проверка удаляемости Repo
- Проверить удаляемость Repo, если есть хотябы 1 Unit

### Cценарий 3 - Модификация 
- Обновить название
- Попытаться обновить название на занятое
- Обновление видимости
- Попытаться установить автоматическое обновление Unit без установки коммита и ветки
- Изменить автоматическое обновление Unit на ручное
- Изменить ручное обновление на автоматическое
- Попытаться модифицировать Unit без полномочий создателя

### Cценарий 4 - Работа с файлом окружения
- Получить файл окружения у верссии в которой он есть
- Попытаться установить переменную, которой нет в env_example.json
- Установить всем тестовым Unit env.json

### Сценарий 5 - Получение прошивки
- Получить прошивку zip, tar, tgz и проверить env.json файлы
- Попробовать получить прошивку через tgz со сломанными wbits и level
- Проверить получение таргет версии для Unit

### Сценарий 6 - Работа хранилища для Unit
- Проверка сохранения и получения данных из хранилища
- Проверка возникновения ошибки для данных большой длинны

### Сценарий 7 - Запуск контура инфраструктуры
- Запустить N Units через threading

### Сценарий 8 - Обновление Unit напрямую
- Перевести все Unit на существующие старые версии
- Попробовать Unit на несущетвующую версию
- Попробовать перевести Unit на версию с невалидным env_example.json
- Попробовать обновить с невалидным env.json

### Сценарий 9 - Обновление Unit автоматически через Repo
- Обновить Repo руками на определённую версию, проверить связанные Unit
- Обновить Repo обновляющийся на последнюю версию, через вызов автоматического обновления, проверить связанные Unit

## Сценарий 10 - Тест команды обновления окружений Unit
- Отправить команду на обновление env у Unit и проверить изменение в env.json

## Сценарий 11 - Тест команды принудительной синхронизации Unit
- Отправить команду синхронизации лога у Unit и проверить число записей

### Сценарий 12 - Множественная выборка Unit
- Выборка по всем параметрам

### Сценарий 13 - Множественная выборка логов у Unit
- Выборка по всем параметрам

## Сценарии UnitNode

### Cценарий 1 - Модификация UnitNode
- Обновить видимость
- Обновить для Input презаписываемость
- Попробовать обновить для Output презаписываемость
- Активировать DataPipe

### Cценарий 2 - Установка DataPipe
- Установка корректных YAML
- Установка не корректных YAML
- Проверка YAML на корректность через спец ручку

### Cценарий 3 - Получение DataPipe
- Получение конфига
- Проверка получения не загруженного конфига при активном DataPipe
- Проверка получения конфига при неактивном DataPipe

### Сценарий 4 - Взаимодействие
- Каждое взаимодействие - это установка input UnitNode, который автоматически передаётся в output UnitNode на стороне Unit, с логированием в json файл
- Установить связи UnitNodeEdge
- UnitNode Output -> Input - Public - Internal
- UnitNode Output -> Input - Internal - Private
- Обновить состояние схемы на устройствах
- Отправить значение в Input топик - Public Unit
- Попробовать установить значение со стороны Pepeunit для Output топика
- Проверить log.json каждого из Unit на предмет нужного значения

### Сценарий 5 - Установить значения Input
- Попробовать установить значения для Input от имени Unit с проставленным флагом is_rewritable_input=False и True

### Сценарий 6 - Получение UnitNodeEdge по unit_uuid
- Получить все связи определённого Unit

### Сценарий 7 - Удаление UnitNodeEdge
- Удалить существующий UnitNodeEdge
- Попробовать удалить не существующий UnitNodeEdge

### Сценарий 8 - Множественная выборка UnitNode
- Выборка по всем парамтерам фильтра

### Сценарий 9 - Удаление Unit
- Удалить Unit
- Проверить что его нет

### Сценарий 10 - Проверка распределения версий для Unit по Repo uuid
- Проверить получение статистики - какие версии используют Unit у конкретного Repo

### Сценарий 11 - Проверка получения данных DataPipe
- Проверка для каждой из политик, есть ли данные после интеграционника

### Сценарий 12 - Проверка получения данных DataPipe через csv
- Получаем сsv

### Сценарий 13 - Проверка удаления данных в DataPipe
- Проверка удаления за раз, всех политик для конкретного DataPipe


## Сценарии Permission

### Сценарий 1 - Создание Permission
- Создать Permission между другим Пользователем и приватным Unit
- Попробовать содать Permission с несуществующим Агентом
- Попробовать содать Permission с несуществующим Ресурсом

### Сценарий 2 - Получение Permission
- Получить все Ресурсы по Агенту
- Попробовать получить все Ресурсы по несуществующему Агенту

### Сценарий 3 - Удаление Permission
- Удалить существующий Permission
- Попробовать удалить несуществующий Permission

## Сценарии Metrics

### Сценарий 1 - Создание Metrics
- Получить все метрики инстанса
