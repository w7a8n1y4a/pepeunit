# 0.9.0 Система бордов

## Автоматическая авторизация при переходе по ссылке на grafana
1. oauth в целом работает, но надо научить его работать по сгенерированному jwt. Т.е. ссылке на графану, с упакованным в неё jwt от сервиса pepeunit
    - нужно добавить env переменную в бек, чтобы он знал путь до графана
    - нужно добавить генератор jwt только для grafana, по аналогии с backend, который используется между сервисами
    - нужна ручка, которая по параметрам запроса, сгенерирует jwt для графаны. Параметры зависят от реализации первичной авторизации

## Отображение данных из DataPipe

### Шаблоны графиков
- Добавляются шаблоны графиков, в зависимости от типа хранимых данных и типа агрегации
- Только предварительно созданные, давать возможность создавать их - очень не тревиальная задача

Для всех последних значений:
1. SingleStat / Stat panel — для вывода последнего значения
1. Gauge - измеритель скорости
1. Text - просто текст

Для чисел:
1. Line chart (линейный график) - для Avg/Min/Max/Sum значений с указанием периода (time_window_size) в легенде или цветом.
1. Bar Chart (линейный график) - по сути то же самое что и Line Chart
1. Heat Map - для визуализации плотности значений во времени (например температура по часам суток за неделю).
1. SingleStat / Stat panel — для вывода последнего значения

Для текста + чисел:
1. Logs - отображает текста построчно
1. StateTimeline - отображает текст в виде графика
1. Status History - отображает текст в виде графика
1. Table - отображает текст построчно

### Datasource
Нужна ручка на бекенде, которая бы позволяла по логину присылаемому от графана, отдавать данные по конкретному UnitNode, используя систему доступов Pepeunit

- Реализацию надо делать на основе бекенд datasource, и при этом много тестить как несколько датасурсов работают с одним графиком (шаблоном) или визуализацией как это в доке графаны описано

### Линковка шаблона, UnitNodes в Dashboard на стороне pepeunit

1. Сначала создаётся сущность dashboard в pepeunit c уникальным именем на узле
1. Выбирается шаблон для визуализации
1. К шаблону линкуется N UnitNode, нужен валидатор, который будет смотреть доступна ли такой-то UnitNode для линка в текущий шаблон
1. По необходимости процедура добавления визуализации повторяется

### Модальное окно бордов
1. Имя борда
1. Линк на дешборд если синхронизация прошла успешно
1. Нужен статус синхроназации с ошибкой если есть + время желательно
1. Интерфейс линковки шаблонов
1. Зелёная кнопка - кнопка синхронизации dashboard из pepeunit в grafana
1. Синхронизация работает в 1 сторону, старый борд должен затираться, даже если он был изменён пользователем
1. uuid борда или аналог храним в бд pepeunit

### Settings/Delete
1. Кнопка удаления борда как обычно

### Реестр бордов
1. Поиск только по своим dashboard, по именам
1. Создание как у Реестра репозиториев
1. Отображение как у реестра репозиториев, но кнопки в таблице надо 2:
    - первая на модалку
    - вторая на переход в дешборд


## Новые таблицы и связи

### Dashboards

```text
uuid
grafana_uuid
name - any, но со стандартным ограничем
dashboard_url
last_version int
create_datetime
creator_uuid
```

### DashboardsPanels
```text
type - тип отображения самой визуализации, хетмап, xy
title
dashboard_uuid
```

### MtM UnitNode to DashboardsPanels
```text
is_last_data - только последние значения независимо от типа данных, вычисляемого на основе DataPipe config
unit_node_uuid
dashboards_panels_uuid
```

## Борды Администратора

- Доступ токо с ролью Admin на инстансе pepeunit.
- В графане доступ только Viewer

Какие борды нужны первично:
1. Существующий борд на основе прометиуса бекенда
    - Время запросов + процентили (есть и работает)
    - Как-то заставить работать Memory usage
    - Как-то заставить работать CPU usage
    - Errors per second просто удалить
1. Борд на основе EMQX и его прометиуса
    - Можно дефолтный который у них на странице, видимо надо разобраться как добавить ещё один конфиг в prometheus
1. Логи Backend
    - очень нужно видеть число возникновений каждой ошибки, в идеале видеть не только текст, но и стектрейс хотябы первой возникшей с таким текстом
    - при этом ошибки нужны за 1 неделю, больше нет смысла
    - под эту задачу видимо надо затягивать на проект ещё одну зависимость

## Импорт данных по шаблону

Возможность импортировать уже существующие данные в систему, формат нужно проверять в оответствии с текущими настройками DataPipe

При появлении не соответствия сразу ошибка

1. Для каждой строки смотрим принадлежность интервалу из ActivePeriod
2. Фильтруем типами Text и Number, по приводимости к str и int
3. Фильтруем чёрными и белыми списками
4. Фильтруем диапазонами
5. Проверяем max_rate для значений у window_entry и n_last_entry
6. Проверяем last_unique_check для значений у window_entry и n_last_entry
7. Проверяем max_size для всех
8. Из трансформации работает только round_decimal_point и только для чисел
9. create_datetime монотонно возрастает предыдущий меньше текущего
10. Проверки в зависимости от типа
    1. window_entry
        - state
        - state_type - известен заранее
        - create_datetime
        - expiration_datetime - рассчитывается на основе create_datetime
        - size - рассчитывается

        1. create_datetime должен быть больше чем текущее время минус ProcessingPolicyConfig.time_window_size, но меньше чем текущее время

    2. n_last_entry
        - state
        - state_type - известен заранее
        - create_datetime
        - max_count - известен заранее
        - size - рассчитывается

        1. проверяем что общее число записей, меньше или равно max_count. Можно считать инкремент

    3. agregation_entry
        - state
        - aggregation_type - известен заранее
        - time_window_size - известен заранее
        - create_datetime
        - start_window_datetime
        - end_window_datetime

        1. start_window_datetime < end_window_datetime
        2. start_window_datetime, end_window_datetime ровные и имеют разницу в time_window_size
        3. start_window_datetime, end_window_datetime имеют разницу в time_window_size
        4. create_datetime должен быть равен end_window_datetime
