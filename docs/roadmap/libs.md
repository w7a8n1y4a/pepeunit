# 0.10.0 Библиотека python для PyPi


## Зависимости

Пакет должен иметь возможность скачиваться с pypi в 4 конфигурация:
1. rest - дополнительная зависимость только 1 - httpx
1. mqtt - дополнительная зивисимость только 1 - paho-mqtt
1. all - две дополнительные зависимости httpx и paho-mqtt
1. min - без дополнительных зависимостей

Зависимости отдельно проверять в коде не нужно, просто пусть выбивает стандартные ошибки пользователям если их нет

## Инициализация
- Обязательно - передаётся путь до файлов env.json, schema.json, log.json
- Обязательно но с дефолтными значениями, по умолчанию все клиенты выключены - флагами включаются и выключаются mqtt, rest клиенты
- Не обязательно - клиенты mqtt и rest, нужно для возможности передать клиенты, подходящие под абстрактный класс. Нужно чтобы если пользователь имеет другую библиотеку не httpx и paho, он мог сам написать класс взаимодействия и передать его. По умолчанию если стоят флаги mqtt, rest как true, нужно брать клиенты изнутри этого репозитория, если пользователь передаёт свои клиенты, нужно использовать уже их

## Базовый функционал PepeunitClient:
1. Наличие атрибута settings, позволяющего получать из него значение переменных окружения
    - Все переменные можно получить в формате pepeunit_client_obj.settings.VAR_NAME
1. Наличие атрибута unit_uuid, property который динамически вычисляет unit_uuid из JWT токена .settings.PEPEUNIT_TOKEN, используя встроенную библиотеку base64 для декодирования центральной части токена, ключ `uuid` возвращает unit_uuid
1. Динамическое обновление settings через метод .settings.update_from_file(), путём считывания env.json, всё что строится на основе settings также обновляется
1. Функция обновления программы устройства update_device_program(archive_path: str), по пути до уже скачанного архива с обязательной логикой распаковки tar.gz архивов
1. Функция генерации состояния устройства, схема как в old_client.py - get_system_state
1. Атрибут logger, логер позволяющий сохранять данные в log.json, и если включен mqtt,ы то передавать по mqtt. должно быть 5 типов вызова, каждый из типов вызова это просто property, который сам под капотом назначает тип из enums LogLevel, как значения принимает текст.
    - .logger.debug()
    - .logger.info()
    - .logger.warning()
    - .logger.error()
    - .logger.critical()
1. Функция получения полного лога из log.json
1. Атрибут schema, обновляемый на основе schema.json, к атрибуту schema, обращение должно быть в следующих 4х форматах:
    - .schema.input_base_topic
    - .schema.output_base_topic
    - .schema.input_topic
    - .schema.output_topic
1. Каждый из 4х вспомогательных атрибутов, должен уметь возвращать список, по ключу, например:
    - .schema.output_topic["input/pepeunit"] - должен вернуть ["devunit.pepeunit.com/751ea411-8068-42df-9c65-987f122f670e/pepeunit", ...]
1. При обновлении schema, обновляются и все зависящие вещи

Работа с файлами:
1. Функция обновления env.json, по пути до нового файлаыы
1. Функция получения значений из env.json
1. Функция обновления schema.json, по пути до нового файлаыss
1. Функция получения значений из schema.json
1. Функция обновления log.json, по пути до нового файла
1. Функция получения полного лога из log.json

## Доп. Функционал если включен флаг mqtt
1. Все конфиги клиента mqtt делаются на основе .settings
1. Обработчик входящих данных из топиков, разделён на две части - пользовательскую (mqtt_input_func) и библиотечную (base_mqtt_input_func). Представляет из себя последовательный вызов функций, сначала библиотечной, потом пользовательской (не обязательна)
1. base_mqtt_input_func - Если в schema.input_base_topic есть топики:
    1. update/pepeunit - должен вызывать процедуру обновления, нужен rest флаг
    1. env_update/pepeunit - обработчик должен вызывать процедуру скачивания и установки нового env.json, нужен rest флаг
    1. schema_update/pepeunit - обработчик должен вызвать процедуру скачивания и установки новой schema.json, нужен rest флаг
    1. log_sync/pepeunit - обработчик должен получить полный log.json и отправить его по mqtt в топик .schema.output_base_topic[log/pepeunit], нужен только mqtt флаг, rest не обязателен
1. mqtt_input_func строится по похожему принципу, пользователь также выбирает топик, и пишет логику, но уже свою
1. set_input_message_handler(mqtt_input_func) - устанавливает пользоваетльскую функцию обработки
1. Обработчик исходящих сообщений, то же состоит из двух - пользовательской (mqtt_output_func) и библиотечной (base_mqtt_output_func). Вызов так же последовательный, но способ вызова отличается. Данные функции вызываются также последовательно, но внутри while True цикла. Таким образом все пользовательские вызовы будут сконцентрированы внутри этого цикла. Т.е. пользователь строит функцию, и как только готов запускает цикл.
1. base_mqtt_output_func - Если в .schema.output_base_topic:
    - state/pepeunit, то включить функцию отправки состояния приложения old_client.py - get_system_state по таймеру с интервалом STATE_SEND_INTERVAL из настроек, используя генератор из базового функционала, без rest
    - log/pepeunit, то включить отправку лога по mqtt, отправка идёт вне цикла, сразу напрямую из функции, без rest
1. mqtt_output_func - пишет пользователь по аналогии со своими условиями и передаёт в обработчик
1. run_main_cycle(mqtt_output_func) - функция запуска цыкла, по сути это основной цикл программы
1. stop_main_cycle() - позволяет изнутри цикла завершить его, тем самым завершить работу программы
1. subscribe_topics() - функция подписывается сразу на топики которые в неё переданы
1. subscribe_all_schema_topics() - подписка на все топики из .schema.input_base_topic и .schema.input_topic при помощи subscribe_topics()
1. publish_to_topics() - Функция отправки сообщений в топик mqtt, сразу по заданному, например .schema.output_topic[output/pepeunit] и на все топики в этом списке уходит сообщение mqtt


## Доп. Функционал если включен флаг rest
1. Headers и пути до ручек rest клиента делаются на основе .settings
1. download_update() - скачивание архива обновления через rest, пример есть в old_client.py, оставим только tar.gz, т.к. самый простой
1. download_env() - скачивание env.json
1. download_schema() - скачивание schema.json
1. set_state_storage(uuid, state) - загрузка в Pepeunit Unit Storage
1. get_state_storage(uuid) - получение из Pepeunit Unit Storage
1. Путь для Unit Storage API: <env_domain>/<env_prefix>/<env_api_prefix>/unit/{uuid} 

## Доп. Функционал если передаются оба клиента (MQTT + REST)
1. perform_update() - полный цикл обновления: MQTT получает команду → REST скачивает → базовый класс обновляется


## Основной флоу библиотеки

1. Создаётся клиент
1. Пользователь создаёт функцию mqtt_input_func, тем самым описывая, как обрабатываются входящие сообщения
1. Пользователь создаёт фунцкию mqtt_output_func, тем самым описывая, как он отправляет исходящие сообщения
1. Пользователь устанавливает - set_input_message_handler(mqtt_input_func)
1. Пользователь запускает подписку на все топики subscribe_all_schema_topics(), с этого момента приложение начинает обработку входящих сообещний
1. Пользователь запускает цикл - run_main_cycle(mqtt_output_func) - с этого момента начинается основная работа приложения

## Работа с ошибками

1. print для логов не используем, как и обычный logging, если ошибка падает, пусть падает до конца.
1. Основной цикл run_main_cycle особенный, т.к. он предназначен для длительной работы, там нужно сделать общий обработчик через try except, который будет обрабатывать все ошибки и складировать при помощи .logger.type(). Типы ошибок ещё на подумать.
1. Если комбинация флагов клиентов, не позволяет вызвать определённую функцию, вызываем raise напрямуюы