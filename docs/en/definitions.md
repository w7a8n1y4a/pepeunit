# Definitions

## RepositoryRegistry
`RepositoryRegistry` is Pepeunit's representation of an external [Git](#git) repository (for example from [GitLab](#gitlab) or [GitHub](#github)).  
This entity stores a full copy of the repository and keeps its state synchronized with the external repository.  
On top of this entity, [Repo](#repo) objects are created.

## Repo
`Repo` is an internal [Pepeunit](/en/conception/overview) entity that connects a [RepositoryRegistry](#repositoryregistry) with a [Unit](#unit) and allows you to manage a pool of [Units](#unit).  
You can configure updates for all related [Units](#unit) at once and update them manually or automatically.  
The main purpose of this entity is to decouple the logical [Unit](#unit) from its [RepositoryRegistry](#repositoryregistry).

## Unit
`Unit` is a representation of a physical [IoT](#iot) device in [Pepeunit](/en/conception/overview).  
This entity is created from a [Repo](#repo) and holds information about a specific physical [IoT](#iot) device and the firmware version available in that [Repo](#repo).

## UnitNode
`UnitNode` is a representation of an [MQTT](#mqtt) topic in [Pepeunit](/en/conception/overview).  
This entity describes an interaction point with a [Unit](#unit). A `UnitNode` can be of two types: `Input` and `Output`.  
`UnitNodes` of different [Units](#unit) can be connected via links from one `Output` to many `Input`s.

## Datasource
`Datasource` is a data source in [Grafana](/en/deployment/dependencies/grafana) from which Grafana reads data for visualization.  
The [Backend](/en/deployment/dependencies/backend) exposes a ready-to-use [REST](#rest) endpoint for [InfinityAPI](https://grafana.com/grafana/plugins/yesoreyeram-infinity-datasource/) for each organization.  
Such a request, using `headers` and `params`, allows you to retrieve data accumulated by [DataPipe](/en/deployment/dependencies/datapipe) mechanisms.

## Visualization
`Visualization` (a panel) is a way to display data in [Grafana](/en/deployment/dependencies/grafana).  
Each separate visualization can contain several [Datasources](#datasource) of one or more types.  
You can bind multiple [UnitNodes](#unitnode) with configured [DataPipes](/en/deployment/dependencies/datapipe) to a single visualization.  
When building visualizations, make sure that the data format is consistent.

## Dashboard
`Dashboard` is a set of [Visualizations](#visualization) in [Grafana](/en/deployment/dependencies/grafana) combined on a single page for convenient monitoring and analysis.

## schema_example.json
`schema_example.json` is a schema file that describes [MQTT](#mqtt) topics required by a [Unit](#unit).  
It is created by a [Unit Developer](/en/development-pepeunit/mechanics/roles#unit-developer) and placed into every version of a [Repo](#repo).  
Using this file, [Pepeunit](/en/conception/overview) creates [UnitNode](#unitnode) entities responsible for interacting with a [Unit](#unit) and enforcing access policies to that Unit's topics.  
[Learn more](/en/developer/files/struct-schema-example-json#schema-example-json)

## schema.json
`schema.json` is the final schema file for a [Unit](#unit) generated by [Pepeunit](/en/conception/overview).  
It contains links to [UnitNodes](#unitnode) and the base topics used to interact with [Pepeunit](/en/conception/overview).  
[Learn more](/en/developer/files/struct-schema-json#schema-json)

## env_example.json
`env_example.json` is a file that describes the environment variables required for proper [Unit](#unit) operation.  
It is created by a [Unit Developer](/en/development-pepeunit/mechanics/roles#unit-developer) and placed into every [Repo](#repo) version.  
Based on this file and the [User](/en/development-pepeunit/mechanics/roles.html#user) input, [Pepeunit](/en/conception/overview) can generate an [env.json](#envjson) file for a [Unit](#unit).  
[Learn more](/en/developer/files/struct-env-example-json#env-example-json)

## env.json
`env.json` is a secret file that contains environment variables required for correct [Unit](#unit) operation.  
This is exactly the file that makes your [Unit](#unit) different from other [Units](#unit) created from the same [Repo](#repo).

It is created by the [Unit](#unit) owner together with [Pepeunit](/en/conception/overview) and is stored in an [encrypted](/en/development-pepeunit/mechanics/cipher) form inside the [Unit](#unit) entity.  
[Learn more](/en/developer/files/struct-env-json#env-json)

## pepeunit.toml
`pepeunit.toml` is a standardized information block of a [Unit](#unit) that contains exhaustive information about the Unit.  
It is placed in the root of the [Git](#git) repository and serves as a machine-readable description of the [Unit](#unit) for [Pepeunit](/en/conception/overview).  
The closest analogue in software development is [pyproject.toml](https://packaging.python.org/en/latest/guides/writing-pyproject-toml/).  
[Learn more](/en/developer/files/struct-pepeunit-toml#pepeunit-toml)

## readme.md
`readme.md` or `README.md` is a documentation file inside a [Git](#git) repository.  
At the author's discretion, it may contain basic information about the repository, specifics, configuration steps, or any other information deemed important.  
In [Pepeunit](/en/conception/overview), a generator based on [pepeunit.toml](#pepeunit-toml) is used to populate `readme.md`.  
[Learn more](/en/developer/files/struct-readme#readme-md)

## .gitignore
[.gitignore](https://git-scm.com/docs/gitignore) is a file that lists files and directories that [Git](#git) must ignore.  
It supports patterns to make cleanup easier.  
[Learn more](/en/developer/files/struct-gitignore)

## .pepeignore
`.pepeignore` is a file with syntax similar to [.gitignore](#gitignore) in [Git](#git) repositories for [Units](#unit).  
It allows you to remove all listed files and directories from the repository when generating a [program archive](/en/developer/files/struct-archive-update) for [Interpretable](#interpretable) [Units](#unit).  
[Learn more](/en/developer/files/struct-pepeignore)

## LICENSE
`LICENSE` is a license file placed in the root of a [Git](#git) repository that governs the legal aspects of repository usage.  
[Pepeunit](/en/conception/overview) repositories are published under the `AGPL v3` license; authors of their own repositories choose a license themselves (see [spdx.org](https://spdx.org/licenses/)).

## Micropython
[Micropython](https://docs.micropython.org) is a lean and efficient implementation of the `Python 3` programming language that includes a small subset of the standard `Python` library and is optimized for microcontrollers and constrained environments.

## Golang
[Go](https://go.dev/), or `Golang`, is a compiled, statically typed programming language well suited for high-load systems.

## Fediverse
[Fediverse](https://en.wikipedia.org/wiki/Fediverse) is a way of organizing `server-to-server` interaction that provides a decentralized model of information distribution and processing.

## IoT
`Internet of Things (IoT)` is a global ecosystem of interconnected devices, where everyday objects such as fridges, light bulbs or cars gain common capabilities for interaction thanks to built‑in sensors, chips and internet connectivity, and autonomously exchange data to simplify human life.

## Framework
`Framework` is a ready‑made software structure or scaffold for application development.  
It defines the application architecture, controls execution flow and lifecycle, provides a set of components and tools, and offers extension points for plugging in your own logic.

Unlike a library, a framework dictates how code should be organized and calls user code at its own discretion.

## Git
[Git](https://git-scm.com/) is a free, open‑source distributed version control system designed for fast and efficient work with projects of any size, from small to very large.

## Interpretable
`Interpretable` refers to a family of programming languages in which code is executed by an interpreter (often via bytecode / JIT) without mandatory ahead‑of‑time compilation to a standalone executable.

## Compilable
`Compilable` refers to a family of programming languages in which code is compiled to machine code or bytecode before execution, and is then run directly or via a virtual machine / JIT.

## Git Commit
`Commit` is the recorded state of code or any other byte structure at a specific point in time in the [Git](#git) version control system.  
Each [commit](#git-commit) has a unique identifier and usually a `description` — a text summary of the changes it contains.

## Git Tag
`Tag` is a special label pointing to a [commit](#git-commit).  
Tags are usually assigned to stable release commits of a program and represent its version.

## Git Branch
`Branch` is an ordered set of [commits](#git-commit) arranged in chronological order in the [Git](#git) version control system.

## GitLab
`GitLab` is a web‑based lifecycle tool for [Git](#git) repositories by `GitLab Inc`.  
In this documentation, `GitLab` refers both to [gitlab.com](https://about.gitlab.com/) and any other instance of `GitLab CE` or `GitLab EE`.

## GitHub
[GitHub](https://github.com/) is a hosting service for [Git](#git) repositories operated by `GitHub, Inc.`.

## SQL
`SQL (Structured Query Language)` is a declarative programming language for creating, modifying, and managing databases.

## API
`Application Programming Interface (API)` is a set of interaction rules exposed by software that describes how to work with it.  
It is usually described by a set of contracts.  
For example, the [Pepeunit](/en/conception/overview) [Backend](/en/deployment/dependencies/backend) exposes [REST](#rest), [GQL](#gql), and [MQTT](#mqtt) APIs.

## REST
`REST API` is an architectural style that describes how a program interacts with clients using `HTTP` requests.  
The Pepeunit [Backend](/en/deployment/dependencies/backend) uses [Pydantic](https://docs.pydantic.dev/latest/) and the [OpenAPI](https://swagger.io/docs/) specification to expose a `REST API`.

## GQL
`GraphQL API` is a query language and open‑source server runtime that uses `HTTP(S)` for requests.  
The [Pepeunit](/en/conception/overview) [Backend](/en/deployment/dependencies/backend) uses [strawberry-graphql](https://strawberry.rocks/docs) to provide its `GraphQL API`.

## MQTT
`MQTT` is a lightweight network protocol running on top of `TCP/IP`, focused on publish‑subscribe messaging.  
The [Pepeunit](/en/conception/overview) [Backend](/en/deployment/dependencies/backend) uses [fastapi-mqtt](https://sabuhish.github.io/fastapi-mqtt/) as a client to interact with [EMQX](deployment/dependencies/emqx).

## Telegram
[Telegram](https://telegram.org/) is a popular messaging application that provides [Telegram Bot](#telegram-bot) functionality.

## Telegram Bot
[Telegram Bot API](https://core.telegram.org/bots/api) is an open [API](#api) for interacting with services external to [Telegram](#telegram), such as [Pepeunit](/en/conception/overview).  
To integrate with the `Telegram Bot API`, [Pepeunit](/en/conception/overview) uses [AioGram](https://github.com/aiogram/aiogram) as a client.  
`Telegram Bot API` allows the [Backend](/en/deployment/dependencies/backend) to verify [Users](/en/development-pepeunit/mechanics/roles.html#user).  
Bots are managed via [Bot Father](https://t.me/BotFather).

## YML
`YML` or `YAML` is a human‑readable data format used for serialization and configuration.  
It is widely used in automation and pipelines to describe stages and their parameters.  
[Pepeunit](/en/conception/overview) uses it for data pipelines.
