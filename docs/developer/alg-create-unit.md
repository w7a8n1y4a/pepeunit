# Алгоритм создания Unit

Пройдя последовательно данный алгоритм, вы создадите свой первый Unit.

## Проработка идеи

Перед началом разработки Unit ответьте себе на следующие вопросы:
1. Какую основную задачу будет решать ваш Unit?
1. Какие физические элементы будут у вашего Unit?
1. Какие данные Unit будет публиковать?
1. Какое управляющее воздействие будет допускать Unit?
1. Компилируемый или Интерпритируемый будет ваш Unit?

:::info Например
1. Регулирование температуры при помощи вентилятора
1. Для esp32, 4pin вентилятор, температурный датчик DS18B20
1. Скважность PWM сигнала управления Вентилятором и Температуру на датчике
1. Включение на N секунд заданной скорости вращения
1. Интерпритируемый
:::

## Создание удалённого репозитория

Перейдите в удобный вам инстанс Gitlab или Github:
1. Создайте пустой репозиторий
1. Склонируйте его на свою ЭВМ

## Создание файловой структуры

1. Откройте склонированный репозиторий любым удобным для вас редактором кода
1. Создайте следующий минимальный набор пустых файлов:
    - `env_example.json`
    - `.gitignore`
    - `LICENSE` - на ваш вкус
    - `readme.md`
    - `schema_example.json`

## Заполнение .gitignore

Впишите следующий набор дирректорий и файлов:
```gitignore
env.json
schema.json
tmp
```

Не забудьте указать папку с вашей `IDE` это может быть `.idea`, `.nvim` или любая другая. Более подробно о заполнении .gitignore.

## Заполнение schema_example.json

:::info
Подробно о заполнении schema_example.json
:::

Копируем в файл schema_example.json стандартные топики:

```json
{
    "input_base_topic": [
        "update/pepeunit",
        "schema_update/pepeunit",
        "env_update/pepeunit"
    ],
    "output_base_topic": [
        "state/pepeunit"
    ]
}
```

Удаляем те топики которые не будем поддерживать. Что делают `input_base_topic` можно увидеть в документации команд, что делают `output_base_topic` можно увидеть в документации по отправке состояний.

Примем решение оставить всё, хочется рабочую систему обновлений, а также обновлять схему и окружение по MQTT команде. Состояние Unit также было бы хорошо отслеживать.

Добавим пользовательские топики

В `input_topic` добавим `set_fan_state/pepeunit`, Unit подпишется на него и будет получать управляющие команды, изначально хотелось - `Включение на N секунд заданной скорости вращения`.

В `output_topic` добавим два: `current_fan_speed_percentage/pepeunit`, `current_temp/pepeunit` - в эти топики будем публиковать текущее состояние. Изначально хотелось - `Скважность PWM сигнала управления Вентилятором и Температуру на датчике`

Добавляем нужные топики в schema_example.json:
```json
{
    "input_base_topic": [
        "update/pepeunit",
        "schema_update/pepeunit"
    ],
    "output_base_topic": [
        "state/pepeunit"
    ],
    "input_topic": [
        "set_fan_state/pepeunit"
    ],
    "output_topic": [
        "current_fan_speed_percentage/pepeunit",
        "current_temp/pepeunit"
    ]
}
```

:::warning
В процессе разработки может потребоваться изменение schema_example.json - это абсолютно нормально. Добавьте или удалите топики и актуализируйте Readme. Pepeunit подстроится и добавит/удалит UnitNode.
:::

## Заполнение env_example.json

:::info
Подробно о заполнении env_example.json
:::

Копируем в файл env_example.json стандартные переменные Pepeunit, так как это пример для заполнения пользователями - все значения должны быть обезличены:
```json
{
    "PEPEUNIT_URL": "unit.example.com",
    "HTTP_TYPE": "https",
    "MQTT_URL": "emqx.example.com",
    "PEPEUNIT_TOKEN": "jwt_token",
    "SYNC_ENCRYPT_KEY": "32_bit_encrypt_key",
    "SECRET_KEY": "32_bit_secret_key",
    "PING_INTERVAL": 30,
    "STATE_SEND_INTERVAL": 300
}
```

Мотивация для добавления дополнительных переменных:
- `WIFI_SSID` - для подключения к WiFi точно понадобится название сети
- `WIFI_PASS` - для подключения к WiFi точно будет нужен пароль
- `PUBLISH_SEND_INTERVAL` - хочу настраивать часту отравки сообщений в Pepeunit
- `DUTY_MIN` - хочу иметь возможность установить минимальную скорость вентилятора
- `DUTY_MAX` - хочу иметь возможность установить максимальную скорость вентилятора
- `TEMP_MIN` - начала окна температур, с которым будет работать моё Unit
- `TEMP_MAX` - конец окна температур, с которым будет работать устройство

Теперь добавляем данные переменные в обезличенном виде в env_example.json, получится следующее:

```json
{
    "WIFI_SSID": "My_Perfect_Wifi_SSID",
    "WIFI_PASS": "Strong_Password",
    "PUBLISH_SEND_INTERVAL": 10,
    "DUTY_MIN": 8192,
    "DUTY_MAX": 65535,
    "TEMP_MIN": 30,
    "TEMP_MAX": 60,
    "PEPEUNIT_URL": "unit.pepemoss.com",
    "HTTP_TYPE": "https",
    "MQTT_URL": "emqx.pepemoss.com",
    "PEPEUNIT_TOKEN": "jwt_token",
    "SYNC_ENCRYPT_KEY": "32_bit_encrypt_key",
    "SECRET_KEY": "32_bit_secret_key",
    "PING_INTERVAL": 30,
    "STATE_SEND_INTERVAL": 300
}
```

:::warning
Переменные могут поменяться в процессе разработки - это абсолютно нормально. Добавьте или удалите переменные в env_example.json и актуализируйте Readme. Pepeunit отобразит новые переменные пользователям для ввода, когда они изменят таргет версию.
:::

## Первичное заполнение Readme

Используя документацию по общей структуре Readme первично заполните пункты:
- `Description`
- `Firmware format`
- `Hardware platform`
- `Required physical components`
- `env_example.json`
- `schema_example.json`

## Первый коммит и git push

Вы заполнили минимально нужные файлы, пора их закомитить:
1. Переходим в консоль дирректории вашего проекта
1. `git add .` - добавляем все файлы в кандидаты на коммит
1. `git commit -m "feat(init): initial files"` - коммитим изменения
1. `git push` - отправляем изменения в ваш удалённый хостинг Gitlab или Github

## Создание тестового Unit в Pepeunit

Для продолжения разработки нам нужно будет отправлять и получать управляющее воздействие на Unit. Очень удобно для этого использовать инстанс Pepeunit, которому вы доверяете. Нужно выполнить два шага на этом инстасе:
1. Создайте Repo на основе вашего Git репозитория из Gitlab и Github
1. Создайте Unit:
    - Обязательно сделайте его обновляемым в ручную, чтобы чётко контролировать версию
    - Заполните переменные окружения
    - Скачайте архив с env.json и schema.json

Полученные файлы env.json и schema.json будут содержать данные для подключения к инстансу, а также топики для публикации. По сути теперь вы готовы разрабатывать программный код вашего Unit. В процессе разработки вы сможете заходить в тестовый Unit и видеть какие данные он отправляет в Output UnitNode, создавать для него управляющее воздействи через Input UnitNode. Отлаживать систему обновлений.

## Наполнение Unit функционалом

Для создания функционала - итеративно прорабатывайте аспекты работы вашего приложения, начните c тестирования библиотек получения данных с датчиков и постепенно идите в сторону реализации отправки данных, получения управляющего воздействия и интеграции с Pepeunit.

Здесь всё индивидуально, разработчики Pepeunit могут лишь облегчить вам работу предоставив примеры для разных языков программирования:

- [esp32 Micropython](https://git.pepemoss.com/pepe/pepeunit/units/wifi_pc_fan_4_pin.git)
- [esp8266 Micropython](https://git.pepemoss.com/pepe/pepeunit/units/wifi_temp_sensor.git)
- [go](https://git.pepemoss.com/pepe/pepeunit/units/go_hotkeys.git)

:::info
Вы можете делать множество коммитов с рабочим и не рабочим функционалом, создавать ветки и делать всё что позволяет Git, но настенет момент во времени когда вы увидите, что всё что вы задумали корректно работает. В этот момент нужно перейти в следующему пункту.
:::

## Актуализация документации

Актуализируйте и дозаполните все пункты документации, согласно руководству. Пользователи скажут вам большое спасибо.

## Присвоение Тега

Readme заполнен, функционал готов, всё работает корректно. Самое время присвоить Тег для вашего последнего коммита.

1. Переходим в консоль дирректории вашего проекта
1. Выполняем команду `git tag 1.0.0`
1. Выполняем команду отправки во внешний репозиторий `git push --tags`

Тег будет сигнализировать пользователям, что всё готово к эксплуатации и протестировано разработчиком. Пользователи будут ожидать, что выбрав последний тег - получат самую рабочую, самую актуальную версию Unit.
