# Создаём IoT устройство способное к глобальному масштабированию

- статью переделать в как я решил свою личную проблему мб и вам поможет

## Пролог

Я увлекаюсь IoT уже более 7 лет, собрал множество устройств и программ для них: от gps логера для велосипеда и счётчика Гейгера с передачей данных, до делительных головок и муфельной печи с wifi управлением. Достаточно стандартный набор diy интузиаста.

В основном это устройства на платформах esp8266, esp32 и arduino. У всех этих подделок разный срок работы и судьба. Некоторые проработали 15 минут и сгорели, другие продержались до сегодняшнего дня, третие окислились на пол пути или вовсе утонули. Все эти устрйства были далеки от парадигм программирования, версионирования и масштабирования - они жёстко кодировали свои настройки. Нельзя себе представить ситуацию, в которой другой человек может использовать эти проекты себе во благо.

Посдовательность моего пути в IoT выглядела примерно так:

1. Получил понимание работы с микроконтроллерами в Arduino IDE
1. Дорос до VS Code в сочетании с Platformio
1. Примерно в то же время понял что без Git для контроля версий - никуда
1. Перешёл на Micropython для ускорения разработки

В начале пути каждый раз приступая к новому устройству меня ждало несколько дней или недель в обнимку с поисковиком, доскональному изучению тематических форумов и анализа видео. Мне нужно было только одно, интеграция переферии в мой код. И хотя поиск github сильно облегчал эту задачу, обычно на специфичные датчики или драйвера моторов, очень повезёт если найдётся хотябы 1 упоминание. В альтернативном случае придётся самому создавать программу для интеграции устройства, разбирая даташит.

Попытки совместить в голове программную часть и физическую, иногда приводили к полному сгоранию послденей. Зачастую эти причины были связаны с отсутствием схем подключения или разными напряжениями. Очень редко можно найти хороший репозиторий, который спасёт тебя от описанных участей, а найти репозиторий в котором есть схема подключений, это чудо.

Также стоит отметить, что почти все репозитории для IoT используются другими пользователями, только с целью раздербанить их на составляющие и использовать эти маленькие кусочки в своём коде. Это связано с двумя аспектами:
1. Все настройки захардкожены
2. Одно устройство имеет очень большую зону ответственности

Разработчиков IoT можно в целом разделить на три лагеря:
1. Новички - уже умеет писать рабочие программы, которые выполняют свои задачи
2. Энтузиаст - использует git, умеет пользоваться поиском github, может решить почти любую задачу, но библиотеку по даташиту на датчик ещё не напишет или напишет, но убъёт на это месяц
3. Профи - серьёзные ребята, напишут вам библиотеку на любой датчик по даташиту или просто из головы, они умеют предоставить гарантии по работе своих программ, в основном они либо работают в сфере IoT и в опенсорс выкладывают библиотеки, которыми активно пользуются новички и энтузиасты или создают исключительно устройства для продажи

Схема проста, новички учатся на примерах репозиториев от энтузиастов, а профи пишут библиотеки для новичков и энтузиастов

Что можно предпринять, чтобы ускорить прогресc IoT индустрии с открытым кодом?

Как мне кажется энтузиастам не хватает ПО, которое бы позволяло организовывать их устройства, в единые управляемые системы, по аналогии как делают на серьёзных производствах с контроллерами промышленного уровня Siemens, Mitsubishi и тд. В промышленном мире очень серьёзные гарантии исполнения, дублирование оборудования и системы отката процессов. Обычно такие системы имеют тяжёлые самописные или глубоко интегрированные SKADA системы, они стоят на производствах, атомных реакторах и почти на любом серьёзном заводе, где важен настоящий realtime, чтобы соответствовать уровню надёжности системы обычно работа идёт в 3 смены персонала с запасной сменой.

В то же время максимум гарантий который обычно есть у энтузиаста - это перезагрузка в случае потери питания, переподключение к wifi и брокеру, обработка ошибочных значений. Даже этот минимальный минимум есть не во всех репозиториях github.

Есть много популярных сервисов, заменяющих собой абстрацию SKADA систем для этузиастов: Blynk, Home Assistant, ThingSpeak, Cayenne и тд - наверняка есть аналоги в Yandex, Google, Aws облаках. Из минусов, что большинство из них платные и рассчитаны в основном на готовые устройства от крупных компаний, но при этом у них есть поддержка самописных устройств. Но как мне кажется не достаточная в текущих реалиях.

Есть ряд вполне осязаемых вещей, которые хочется видеть:
1. CI/CD - хочется иметь набор абстракций в который помещается ссылка на репозиторий gitlab или github, переменные окружения и в итоге можно скачать готовый, персонифицированный архив с устройством
2. Автоматические обновления - OTA существует, но обычно это самописный модуль, который вечно не работает
3. Полная автономность - ставим инстанс себе в локльную сеть и пользуемся
4. Федеративный поиск - чтобы отдельные инстансы видели друг друга и имели общие списки используемых репозиториев (приватных тут конечно же не будет). По сути это поиск репозиториев github + gitlab + ... в одном месте
5. Удобная абстракция для Input Output в pub sub модели - эта надстройка очень хорошо подходит именно для IoT, и позволяет выстроить стойные модели доступов, и как следствие взаимдействие между устройствами без участия бекенда, только устройство - брокер - устройстов, бекенд только как система авторизации и аутентификации. Устройствам конечно нужно хранить схемы подписок, но это не критично
6. Конвейеры данных - зачем мне хранение значений уличного датчика тепературы каждые 10 секунд ? Мне они не нужны, а вам? Давайте агрегировать за час или два. Ивентовые события то же хочется фильтровать, а некоторым значениям с датчиков было бы хорошо линейно изменить размерность

Это не отменяет всю мощь Home Assistant или подобных ему решений, но явно упростит жизнь новичкам, энтузиастам и профи.

Вывод по прологу:
1. Автор Энтузиаст
2. Энтузиасту в лице автора мало функционала в готовых решениях

Очень кстати оказалось, что я +- middle python разработчик с некоторым багажом за спиной, я тянул всякое: CRM комбайны, нагруженные вещи и даже немного web3. А что мне как разработчику стоит написать хотябы MVP своих хотелок ?

## Пишем Pepeunit от идеи до 1.0.0 за 2 года в одиночку

В начале сентября 2023 я начал анализировать, что выступает тайм киллером в моём IoT хобби, и очень быстро пришёл к осознанию вещей описанных в прологе. Eсли заглянуть в репозиторий с документацией на проект и посмотреть на коммиты в ридми, сразу станет понятно, что в 2023 году я был слабым разработчиком, хотя уже писал crud на работе и делал вещи из базовых навыков бэкенд разработчика на python.

И вот примерно к октябрю 2023 у меня в голове созрело, я могу написать то, что мне надо и это будут не тревильные круды, а что-то весёлое, тестируемое, связанное с реальным миром да ещё и с хобби. Одним словом произошёл зацеп.

Путь предстоял тернистый, благодаря опыту в разработке для меня было вполне очевидным, что написать без корректно сформированных концепций в формате тз, большой пэт невозможно. И почти до конца марта 2024 я писал тз не приступая к реализации. Тз к этому моменту представляло из себя файлик где были +- расписаны сущности и что я хочу от проекта. Пришлось также прокачивать свои навыки в программировании, прочитал Fluent Python и как окажется в будущем понял эту мудрую книгу на 15%.

Постепенно примерно к началу лета 2024, я написал бекенд с базовой реализацией почти всех самых основных функций. Но так как я был не самый лучший программист, количество багов локнуло разработку на 100%. Хотя в проекте было разделение на слои, это не сильно спасало.

Что же делать ? Я пришёл к выводу что нужно делать рефатор. Рефактор основательный и желательно с тестами, чтобы закрепить успех. Проверив пирамиду тестирования, было обнаружено два подходящих слоя, модульные и интеграционные. Модульные очень быстро отпали, т.к. большинство багов было с внешними сервисами. Остались интеграционные, пошерстив интенет был сделан вывод что все их делают атомарными, но мне это не совсем подходило, т.к. мне нужно эмулировать внешние IoT устройства. Так появились они - инкрементальные интеграционные тесты. Покрыв все методы на сервисном слое абстркцим, было выявлено столько багов, что тестировщик, если бы это было на работе перестал бы со мной здороваться. Приятным бонусом было очень лёгкое обновление зависимостей проекта, меняй что хочешь. Проект стал на 1000% более живучим.

Всё лето 2024 я наращивал объём бизнес логики и подошёл к моменту, когда пора создать фронтенд. У меня была основная идея: графовое отображение + модалки для крудов. Выбор пал на библиотеку ForceGraph, и предстояло сделать выбор Vue или React. Я выбрал React, только потому, что из коробки React выдавал больше fps в ForceGraph. Позже мне конечно сказали, что можно было использовать ванильную библиотеку и получить такой же fps c Vue. Но я во фронтенде понимал не очень много и единственное, что меня спасло это llm. Без них я бы потратил пару лет на написание и изучение фронтенда. Качество получившегося фронтенда, по моему бекендерскому мнению точно на 3+. Он далёк от индустривальных стандартов во многих аспектах, но его можно дорабатывать, а это самое главное.

До конца 2024 года я занимался тем, что сшивал фронтенд и бекенд, мутация за мутацией, запрос за запросом. Основная беда была в мендежменте ошибок, даже в 1 разработчика хранить списки правок в сообщенях телеграма, сильно демотивировало.

Механизм этой демотивации прост: находим ошибку, вписываем её в телеграм под номером N, правим её на фронтенде, она тянет бекенд, бекенд тянет устройства, но это всё тот же номер N, ловим демотивацию мы делали так много, а зачёркиванут будет всего на 1 пункт из 30. Хорошо что в гитлабе есть интегрированный менеджемнт с бордом, рисуем think, work, test и docs колонки и наслаждаемся. Двигать карточки слева на право - это буквально любимое занятие, с каждым новым передвижением проект становится лучше.

Сшив два главных сервиса я присвоил им первую версию проекта - 0.0.0. Я старался делать API похожим на открытый, чтобы если кто-то захочет написать свой клиент, такая возможность была.


