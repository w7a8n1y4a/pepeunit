# `Pepeunit` MVP
## `Pepeunit` - `IoT` система с графовым управлением

## Типы нод

0. `Unit`
1. `Input variable`
2. `Output variable`

## Типы связей

0. Запись - по разрешению для `Input`
1. Чтение - По разрешению для `Output`

## Система доступа
Аналогия с `gitlab` и `fedo`

0. Без регистрации
1. Пользователи узла
2. Пользователи других узлов - подразумевается что `unit` - могут брать данные из доверенных `pepeunit`, по uuid

# Мысли о работе системы в целом

## создание нового `unit` в `pepeunit`
0. Пользователь создаёт ноду c `unit`
    - вписывается название
    - линк на репозиторий `unit` с программой для контроллера
    - репозиторий содержит обязательно два файла `json_example.json` и `schema.json`
        - `json_example.json` - содержит образец нужных переменных для генерации экземпляром pepeunit
        - `schema.json` - содержит набор переменных требуемых для работы `unit`, в основе это 4 типа:
            - `world_state` - содержит информацию из внешнего мира, которая генерируется сервером без участия других `unit` или пользователя
                - время по UTC-0
            - `unit_state` - содержит общую информацию обновляемую от устройства
                - ip аддрес
                - используемая память
                - время с момента запуска
                - мощность сигнала `wifi` и тд
            - `input_variables` - управляющие переменные `unit`, позволяют передать информацию из вне во внутрь контроллера. Задаются пользователем, через `open api` или через `output` другого `unit`
            - `output_variables` - результирующая переменная `unit`, позволяет передать информацию от `unit` в экземпляр `pepeunit`. Задаётся исключительно `unit`
    - Пользователь нажимает кнопку создать
    - Генерируется нода юнита, так же ноды входящих и выходящих переменных по `schema.json`
    - Генерируется `env.json` для юнита, автоматически проставляются только определённые обязательные переменные
        - `PEPEUNIT_URL` - `link` до экземпляра `pepeunit` который генерирует `env.json`
        - `PEPEUNIT_TOKEN` - `jwt` токен, c шифрованной средней частью
        - `SYNC_ENCRYPT_KEY` - используется для `AES` шифрования с двух сторон, `pepeunit` -> `unit`, `unit` -> `pepeunit`
            - Это замена `https`, т.к. стандартные библиотеки `micropython` не поддерживают большие ассинхронные ключи, поэтому используется `АES` шифрование 32 битными ключами. Известная проблема на форумах `micropython`, если есть идеи или уже готовые реализации, пишите рассмотрим
        - `SECRET_KEY` - используется по аналогии с `jwt` токенами, может быть использован для подписи или какого-то дополнительного шифрования, так же 32 битный
    - Шифруется `env.json` и сохраняется в `unit` ноду
    - Юнит на этом этапе готов к эксплуатации на стороне `pepeunit`
1. Пользователь нажимает на юнит, видит параметры из `unit_state`, а так же ссылку на скачивание `env.json` файла
1. Пользователь скачивает `env.json` файл и добавляет в него пареметры подключения к своему `wifi` - `WIFI_SSID` и `WIFI_PASS`
1. Пользователь клонирует репозиторий, открывает через `PyMakr` программу своего `unit`
1. Добавляет сгенерированный `env.json` в программу, и загружает в контроллер `esp8266`
1. Пользователь запускаяет устройство
1. Пользователь может запросить обновление `env.json` - он сгенерируется заного, при этом прошивку нужно будет изменить в ручную

## Получение данных за период

0. `Open API` - позволяет сделать доставание логов по output переменным достаточно простым, он же может использоваться для graphana
1. todo обдумать это должна быть реляционная бд или какая-то доп система

# Todo

## SLS - State Logger System

0. Прямое логирование
1. Среднее по времени
2. Медиана по времени

## Бот телеги

0. Алертинг по превышению и принижению значений переменных данных
1. Возможность делать борды из кнопок переменных управления

## Графана 

0. Возможность делать борды из данных с реляционных таблиц
